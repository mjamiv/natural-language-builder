"""Secondary load code generators for OpenSees script insertion.

Provides three generator functions that return multi-line Python strings. Those
strings are intended to be inserted into an OpenSeesPy-generated script and
will call ops.pattern(...) and ops.load(...) to apply the loads.

Notes / conventions used here:
- Units: KIS (kip, inch, second). Heights given in inches/feet are converted to
  feet where needed for pressure calculations and kept in kips when applied.
- Pattern tags are deterministic constants so generated code is stable.
"""
from __future__ import annotations
import math
from typing import Iterable, List


def generate_wind_load_code(
    node_tags: Iterable[int],
    girder_depth_in: float,
    barrier_height_in: float = 42,
    deck_elevation_ft: float = 30,
    wind_speed_mph: float = 115,
    span_length_ft: float = 100,
    num_nodes: int = 100,
    drag_coefficient: float = 1.3,
    exposure_alpha: float = 9.5,
    zg_ft: float = 900.0,
    gust_factor: float = 1.0,
) -> str:
    """Return Python code string that applies wind forces to the OpenSees model.

    The generated code computes the velocity pressure PZ per AASHTO:
        PZ = 0.00256 * KZ * G * V^2 * CD    (ksf)
    where KZ is computed for Exposure C via the provided power-law approximation:
        KZ = 2.01 * (z/zg)^(2/alpha)
    The lateral force per node (kips) is taken as:
        F_node = PZ (ksf) * exposed_height (ft) * tributary_length (ft)

    The code produced creates a Plain pattern (tag 1001) and issues ops.load
    calls for each nodeTag (X-direction lateral loads). It also populates a
    results['wind_on_structure'] entry with the per-node loads used.
    """
    node_tags_list = list(node_tags)
    if num_nodes <= 0:
        num_nodes = max(1, len(node_tags_list))

    exposed_height_ft = (girder_depth_in + barrier_height_in) / 12.0
    # estimate height above ground where the pressure is evaluated
    z_ft = deck_elevation_ft + exposed_height_ft

    # Exposure C KZ approximation (per TASK): KZ = 2.01 * (z/zg)^(2/alpha)
    kz = 2.01 * (z_ft / zg_ft) ** (2.0 / exposure_alpha)
    V = wind_speed_mph
    G = gust_factor
    CD = drag_coefficient

    # Pressure in ksf (kips/ft^2)
    PZ_ksf = 0.00256 * kz * G * (V ** 2) * CD

    # tributary length per node (ft)
    trib_len_ft = float(span_length_ft) / float(num_nodes)

    # lateral force per node (kips): pressure (kips/ft^2) * height (ft) * length (ft)
    per_node_kip = PZ_ksf * exposed_height_ft * trib_len_ft

    # Build code string
    code_lines: List[str] = []
    code_lines.append("# Wind on structure (AASHTO 3.8.1.2) - generated by secondary_loads")
    code_lines.append("pat_tag = 1001")
    code_lines.append("ops.pattern('Plain', pat_tag, 1)")
    code_lines.append(f"# inputs: girder_depth_in={girder_depth_in}, barrier_height_in={barrier_height_in}, deck_elevation_ft={deck_elevation_ft}")
    code_lines.append(f"# computed: exposed_height_ft={exposed_height_ft:.6f}, z_ft={z_ft:.6f}, KZ={kz:.6f}, PZ_ksf={PZ_ksf:.6f}")
    code_lines.append("results.setdefault('wind_on_structure', {})")
    code_lines.append("results['wind_on_structure']['per_node_kip'] = %r" % per_node_kip)
    code_lines.append("results['wind_on_structure']['node_forces'] = {}")
    for nt in node_tags_list:
        # apply lateral in global X (positive)
        code_lines.append(f"ops.load({nt}, {per_node_kip:.6f}, 0.0, 0.0)")
        code_lines.append(f"results['wind_on_structure']['node_forces'][{nt}] = {per_node_kip:.6f}")

    return "\n".join(code_lines) + "\n"


def generate_wind_live_load_code(
    node_tags: Iterable[int],
    deck_above_ground_ft: float = 6.0,
    wl_klf: float = 0.10,
    span_length_ft: float = 100.0,
    num_nodes: int = 100,
) -> str:
    """Generate code applying wind on live load (AASHTO 3.8.1.3).

    WL is given in klf (kips per linear foot) at 6 ft above deck. We convert
    to kips per node by multiplying by the tributary length.
    """
    node_tags_list = list(node_tags)
    if num_nodes <= 0:
        num_nodes = max(1, len(node_tags_list))
    trib_len_ft = float(span_length_ft) / float(num_nodes)
    per_node_kip = wl_klf * trib_len_ft

    code_lines: List[str] = []
    code_lines.append("# Wind on live load (AASHTO 3.8.1.3) - generated by secondary_loads")
    code_lines.append("pat_tag = 1002")
    code_lines.append("ops.pattern('Plain', pat_tag, 1)")
    code_lines.append(f"# inputs: wl_klf={wl_klf}, deck_above_ground_ft={deck_above_ground_ft}")
    code_lines.append("results.setdefault('wind_on_live', {})")
    code_lines.append("results['wind_on_live']['per_node_kip'] = %r" % per_node_kip)
    code_lines.append("results['wind_on_live']['node_forces'] = {}")
    for nt in node_tags_list:
        code_lines.append(f"ops.load({nt}, {per_node_kip:.6f}, 0.0, 0.0)")
        code_lines.append(f"results['wind_on_live']['node_forces'][{nt}] = {per_node_kip:.6f}")

    return "\n".join(code_lines) + "\n"


def generate_thermal_load_code(
    node_tags: Iterable[int],
    climate: str = "moderate",
    bridge_length_ft: float = 0.0,
    alpha: float = 6.5e-6,
    fixed_node: int | None = None,
) -> str:
    """Return Python code string for a uniform temperature load case.

    The code computes the thermal strains for rise and fall from a setting
    temperature of 60 F and stores them in results['thermal']. If a fixed_node
    is provided the code will create a placeholder concentrated axial force at
    that node proportional to the strain and a nominal sectional area/E.

    NOTE: This generator does not attempt to know section area or stiffness in
    the model. It computes strains (dimensionless) which can be used by the
    caller to create proper constrained-expansion forces when more model
    information is available.
    """
    climate_lower = climate.lower() if climate else "moderate"
    if climate_lower == "moderate":
        Tmax = 80.0
        Tmin = 0.0
    elif climate_lower == "cold":
        Tmax = 80.0
        Tmin = -30.0
    else:
        # default to moderate
        Tmax = 80.0
        Tmin = 0.0

    Tsetting = 60.0
    dT_rise = Tmax - Tsetting
    dT_fall = Tsetting - Tmin
    eps_rise = alpha * dT_rise
    eps_fall = alpha * dT_fall

    # Build code
    code_lines: List[str] = []
    code_lines.append("# Uniform temperature (AASHTO 3.12.2.1) - generated by secondary_loads")
    code_lines.append("pat_tag = 2001")
    code_lines.append("ops.pattern('Plain', pat_tag, 1)")
    code_lines.append(f"# climate={climate_lower}, Tmax={Tmax}, Tmin={Tmin}, Tsetting={Tsetting}")
    code_lines.append(f"eps_rise = {eps_rise:.12e}")
    code_lines.append(f"eps_fall = {eps_fall:.12e}")
    code_lines.append("results.setdefault('thermal', {})")
    code_lines.append("results['thermal']['eps_rise'] = eps_rise")
    code_lines.append("results['thermal']['eps_fall'] = eps_fall")

    if fixed_node is not None:
        # create a placeholder axial force at the fixed node. Without area/E
        # information we apply a nominal unit force proportional to the strain
        # so downstream code can scale if desired.
        code_lines.append(f"# fixed_node provided: {fixed_node} - apply nominal axial indicator load")
        code_lines.append(f"nominal_unit_kip = 1.0  # indicator value; scale with section area*E as needed")
        code_lines.append(f"ops.load({fixed_node}, nominal_unit_kip, 0.0, 0.0)")
        code_lines.append(f"results['thermal']['fixed_node'] = {fixed_node}")
        code_lines.append("results['thermal']['nominal_unit_kip'] = nominal_unit_kip")

    return "\n".join(code_lines) + "\n"


def generate_braking_force_code(
    node_tags: Iterable[int],
    num_lanes: int = 2,
    bridge_length_ft: float = 100.0,
    num_nodes: int | None = None,
) -> str:
    """Return Python code string applying braking forces per AASHTO 3.6.4.

    The implementation uses the common AASHTO design axle loads:
      - design truck total axle = 72 kip
      - design tandem total axle = 50 kip

    The braking force BR is the maximum of:
      - 25% of truck axles = 0.25 * 72
      - 25% of tandem = 0.25 * 50
      - 5% of (truck + lane load)
      - 5% of (tandem + lane load)

    The generator distributes the resulting force among the provided nodes.
    """
    node_tags_list = list(node_tags)
    if num_nodes is None or num_nodes <= 0:
        num_nodes = max(1, len(node_tags_list))

    truck = 72.0
    tandem = 50.0
    truck_brake = 0.25 * truck
    tandem_brake = 0.25 * tandem

    # lane load assumed to be zero (unknown) so the 5% terms reduce to 5%*truck/tandem
    five_pct_truck_plus_lane = 0.05 * truck
    five_pct_tandem_plus_lane = 0.05 * tandem

    br_kip_single = max(truck_brake, tandem_brake, five_pct_truck_plus_lane, five_pct_tandem_plus_lane)

    total_br_kip = br_kip_single * float(max(1, num_lanes))
    per_node_kip = total_br_kip / float(num_nodes)

    code_lines: List[str] = []
    code_lines.append("# Braking forces (AASHTO 3.6.4) - generated by secondary_loads")
    code_lines.append("pat_tag = 3001")
    code_lines.append("ops.pattern('Plain', pat_tag, 1)")
    code_lines.append(f"# computed: truck_brake={truck_brake}, tandem_brake={tandem_brake}, total_br_kip={total_br_kip}")
    code_lines.append("results.setdefault('braking', {})")
    code_lines.append("results['braking']['per_node_kip'] = %r" % per_node_kip)
    code_lines.append("results['braking']['node_forces'] = {}")
    for nt in node_tags_list:
        code_lines.append(f"ops.load({nt}, {per_node_kip:.6f}, 0.0, 0.0)")
        code_lines.append(f"results['braking']['node_forces'][{nt}] = {per_node_kip:.6f}")

    return "\n".join(code_lines) + "\n"
